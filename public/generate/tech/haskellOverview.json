{"title":"Haskell 语言总览","createAt":"2019-05-07T21:08:00.000Z","updateAt":"2019-05-07T21:08:00.000Z","tags":null,"category":null,"author":null,"content":"## Haskell 语言总览\n\n命令式编程：a = 5 ; => a = 7;\n\n函数式编程：  \n例子: 阶乘，指从 1 到某个数的乘积。  \n一个串列中数字的和，指把第一个数字和剩余的数字的和相加。\n\n<!-- more -->\n\n## 语法\n\n```hs\n<!-- 运算 -->\n2 + 5\n49 * 100\n1892-1472\n5/2\n\n<!-- 优先级 -->\n(50-100)*50\n\n<!-- 布尔 -->\nTrue\nFalse\n&&\n||\nnot\n\n<!-- 相等性 -->\n5 == 5\n'hello' /= 'hi'\n\n<!-- 中缀函数 -->\n1 + 2\n\n<!-- 前缀函数 -->\nsucc 8\nmax 100 101\n\n<!-- 函数调用拥有最高优先级 -->\nsucc 9 + max 5 4 + 1\n\n<!-- 等效于 -->\n(succ 9) + (max 5 4) + 1\n\n<!-- 自定义函数 -->\n1、新建文件，取名为baby.ts，填写代码：\ndoubleMe x = x + x\n\n2、打开ghci，运行 :l baby.hs\n输入 doubleMe 9\n\n<!-- 组合 -->\ndoubleMe x = x + x\ndoubleUs x y = doubleMe x + doubleMe y\n注意，doubleUs 和 doubleMe 不分顺序\n\n<!-- 基本类型 list -->\nlet numbers = [4,8,15]\n合并\n[1,2] + [3,5] => [1,2,3,5]\n获取元素:!!\n[1,2,3] !! 1 => 2\n嵌套\nlet b = [[1,2],[3,5]]\n比较，从第一个元素开始，以此类推: >\n[3,2,1] > [2,2,1]\n\n获取首元素： head\nhead [1,3,5] => 1\n\n获取除头部之后的部分 : tail\ntail [5,4,3,2,1] => [4,3,2,1]\n\n获取最后一个元素 : last\nlast [1,2,3] => 3\n\n获取除最后一个元素之外的部分 : init\ninit [1,2,3] => [1,2]\n\n返回长度: length\nlength [1,2] => 2\n\n判断是否为空: null\nnull [1] => False\n\n反转: reverse\nreverse [1,2,3] => [3,2,1]\n\n获取前几个元素: take\ntake 2 [1,2,3] => [1,2]\n\n删除前几个元素: drop\ndrop 2 [1,2,3] => [3]\n\n获取最大元素: maximum\nmaximum [1,2,3] => 3\n\n获取最小元素: minimum\nminimum [1,2,3] => 1\n\n获取元素之和: sum\nsum [1,2,3] => 6\n\n获取元素之积: product\nproduct [1,2,3] => 6\n\n判断元素是否存在： elem\n1 `elem` [1,2,3] => True\n\n<!-- range -->\n[1..5] => [1,2,3,4,5]\n[1,3..9] => [1,3,5,7,9]\n\n重复list: cycle\ntake 3 (cycle [1,2]) => [1,2,3]\n\n重复单个元素： repeat\ntake 3 (repeat 5) => [5,5,5]\n\n指定重复次数: replicate\nreplicate 3 10 => [10,10,10]\n\n<!-- comprehension -->\n[ x*2 | x <- [1..3]>] => [2,4,6]\n\n条件\n[ x | x <- [50..100], x `mod` 7 == 3] => [52,59,66,73,80,87,94]\n\n<!-- Tuple -->\n(8,'one')\n\n返回序对的首项： fst\nfst (8,10) => 8\n\n返回序对的尾项： snd\nsnd (8,11) => 11\n\n交叉配对： zip\nzip [1,2] [3,3] => [(1,3),(2,3)]\n\n<!-- 类型推导 -->\n当你写下一个数字，Haskell能自己推断出它的类型\n\n检查类型： :t\n:t 'a' => Char\n\n<!-- 类型声明 -->\n编写函数时，给它一个明确的类型声明是个好习惯\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n\n常见类型\nint 有界整数。对 32 位的机器而言，上限一般是 2147483647，下限是 -2147483648。\n\nInteger,无界整数，效率不如Int高。\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\nFloat 表示单精度的浮点数。\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\nDouble 表示双精度的浮点数。\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n\nBool 表示布尔值，它只有两种值：True 和 False。\n\nChar 表示一个字符。一个字符由单引号括起，一组字符的 List 即为字符串。\n\nTuple 的类型取决于它的长度及其中项的类型。注意，空 Tuple 同样也是个类型，它只有一种值：()。\n\n\n<!-- Typeclasses -->\n描述类型\n\nghci> :t (==)\n(==) :: (Eq a) => a -> a -> Bool\n=> 符号。它左边的部分叫做类型约束。这段类型声明可以这样理解：\"相等函数取两个相同类型的值作为参数并回传一个布尔值，而这两个参数的类型同在 Eq 类之中(即类型约束)\"\n\n常见 Typeclass\n\n判断相等的类型： Eq\n\n比较大小的类型： Ord\n\n可用字符串的类型： show\nshow 3.1 => '3.1'\n\n将字符串转为Read的某成员类型： read\nread \"5\" - 2   => 3\n\n一个表达式后跟:: 的类型注释，以明确其类型\nread \"5\" :: Int  => 5\n\n连续类型： enum\n每个值都有后继子 (successer) 和前置子 (predecesor)，分别可以通过 succ 函数和 pred 函数得到\n[LT .. GT]  => [LT,EQ,GT]\n\n获取边界： maxBound 与 minBound\nminBound :: Int  => -2147483648\nmaxBound :: Char  => '\\1114111'\n\n数字类型： Num\n:t 20  => 20 :: (Num t) => t\n\n表示整数： Intergral\n\n表示浮点类型： Floating\n\n<!-- 模式匹配 -->\n判断一个数字是否是7\nlucky :: (Integral a) => a -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck, pal!\"\n\n实现阶乘\nfactorial :: (Integral a) => a -> a\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\n二位矢量相加\naddVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\n实现  head 函数\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on an empty list, dummy!\"\nhead' (x:_) = x\n\n实现 length 函数\nlength' :: (Num b) => [a] -> b\nlength' [] = 0\nlength' (_:xs) = 1 + length' xs\n\n@模式,在按模式分割时，保留对其整体的引用\ncapital :: String -> String\ncapital \"\" = \"Empty string, whoops!\"\ncapital all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n\ncapital \"Dracula\"  => \"The first letter of Dracula is D\"\n\nguard 跟在函数名及参数、竖线标志之后，通常他们都是靠右一个缩进排成一列。一个 guard 就是一个布尔表达式，如果为真，就使用其对应的函数体。如果为假，就送去见下一个 guard\n检查体重\nbmiTell :: (RealFloat a) => a -> String\nbmiTell bmi\n    | bmi <= 18.5 = \"You're underweight, you emo, you!\"\n    | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise   = \"You're a whale, congratulations!\"\n\n实现 max 函数\nmax' :: (Ord a) => a -> a -> a\nmax' a b\n    | a > b     = a\n    | otherwise = b\n\nwhere 关键字，定义名字\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weight height\n    | weight / height ^ 2 <= 18.5 = \"You're underweight, you emo, you!\"\n    | weight / height ^ 2 <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | weight / height ^ 2 <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise                   = \"You're a whale, congratulations!\"\n\n    =>\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weight height\n    | bmi <= 18.5 = \"You're underweight, you emo, you!\"\n    | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise   = \"You're a whale, congratulations!\"\n    where bmi = weight / height ^ 2\n\n=>\n\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weight height\n    | bmi <= skinny = \"You're underweight, you emo, you!\"\n    | bmi <= normal = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= fat    = \"You're fat! Lose some weight, fatty!\"\n    | otherwise     = \"You're a whale, congratulations!\"\n    where bmi = weight / height ^ 2\n          skinny = 18.5\n          normal = 25.0\n          fat = 30.0\n\nlet 关键字，定义局部名字\n求圆柱体表面积\ncylinder :: (RealFloat a) => a -> a -> a\ncylinder r h =\n    let sideArea = 2 * pi * r * h\n        topArea = pi * r ^2\n    in  sideArea + 2 * topArea\n\ncase，前面提到的匹配模式其实是case的语法糖\n\nhead' :: [a] -> a\nhead' [] = error \"No head for empty lists!\"\nhead' (x:_) = x\n=>\nhead' :: [a] -> a\nhead' xs = case xs of [] -> error \"No head for empty lists!\"\n                      (x:_) -> x\n\n<!-- 递归 -->\n斐波那契数列\n\n实现 取列表的最大元素\nmaximum' :: (Ord a) => [a] -> a\nmaximum' [] = error \"maximum of empty list\"\nmaximum' [x] = x\nmaximum' (x:xs)\n    | x > maxTail = x\n    | otherwise = maxTail\n    where maxTail = maximum' xs\n\n实现反转\nreverse' :: [a] -> [a]\nreverse' [] = []\nreverse' (x:xs) = reverse' xs ++ [x]\n\n实现 zip\nzip' :: [a] -> [b] -> [(a,b)]\nzip' _ [] = []\nzip' [] _ = []\nzip' (x:xs) (y:ys) = (x,y):zip' xs ys\n\n实现 elem\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' a [] = False\nelem' a (x:xs)\n    | a == x    = True\n    | otherwise = a `elem'` xs\n\n快速排序\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let smallerSorted = quicksort [a | a <- xs, a <= x]\n      biggerSorted = quicksort [a | a <- xs, a > x]\n  in smallerSorted ++ [x] ++ biggerSorted\n\n<!-- 高端函数 -->\n本质上，Haskell所有函数只有一个参数\nghci> max 4 5\n5\nghci> (max 4) 5\n5\n\n实现 zipWith。 它取一个函数和两个 List 做参数，并把两个 List 交到一起(使相应的元素去调用该函数)。\n\nzipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith' _ [] _ = []\nzipWith' _ _ [] = []\nzipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys\n\nzipWith' max [6,3,2,1] [7,3,1,5]  => [7,3,2,5]\n\n实现 flip，取一个函数作参数并回传一个相似的函数，其中它们的参数颠倒了。\nflip' :: (a -> b -> c) -> b -> a -> c\nflip' f y x = f x y\n\nghci> flip' zip [1,2,3,4,5] \"hello\"\n[('h',1),('e',2),('l',3),('l',4),('o',5)]\n\n实现 map，取一个函数和 List 做参数，遍历该 List 的每个元素来调用该函数产生一个新的 List。\n\nmap :: (a -> b) -> [a] -> [b]\nmap _ [] = []\nmap f (x:xs) = f x : map f xs\n\n实现filter，取一个限制条件和一个 List，回传该 List 中所有符合该条件的元素\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter _ [] = []\nfilter p (x:xs)\n    | p x       = x : filter p xs\n    | otherwise = filter p xs\n\n<!-- lambda -->\n匿名函数， \\ (因为它看起来像是希腊字母的 lambda)，后面是用空格分隔的参数，-> 后面就是函数体。\n\n实现 flip\nflip' :: (a -> b -> c) -> b -> a -> c\nflip' f = \\x y -> f y x\n\n<!-- fold -->\n实现 sum\nsum' :: (Num a) => [a] -> a\nsum' xs = foldl (\\acc x -> acc + x) 0 xs\n\n=>\n\nsum' :: (Num a) => [a] -> a\nsum' = foldl (+) 0\n\n常用库函数\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' y ys = foldl (\\acc x -> if x == y then True else acc) False ys\n\nmap' :: (a -> b) -> [a] -> [b]\nmap' f xs = foldr (\\x acc -> f x : acc) [] xs\n\nmaximum' :: (Ord a) => [a] -> a\nmaximum' = foldr1 (\\x acc -> if x > acc then x else acc)\n\nreverse' :: [a] -> [a]\nreverse' = foldl (\\acc x -> x : acc) []\n\nproduct' :: (Num a) => [a] -> a\nproduct' = foldr1 (*)\n\nfilter' :: (a -> Bool) -> [a] -> [a]\nfilter' p = foldr (\\x acc -> if p x then x : acc else acc) []\n\nhead' :: [a] -> a\nhead' = foldr1 (\\x _ -> x)\n\nlast' :: [a] -> a\nlast' = foldl1 (\\_ x -> x)\n\n<!-- $ 函数 -->\n函数调用符，优先级最低\n\nsum (map sqrt [1..130])。由于低优先级的 $，我们可以将其改为 sum $ map sqrt [1..130]，可以省敲不少键！\n\n<!-- 函数组合 -->\n将多个函数组合，即 . 函数\n定义：\n(.) :: (b -> c) -> (a -> b) -> a -> c\nf . g = \\x -> f (g x)\n\n示例\nghci> map (\\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]\n[-5,-3,-6,-7,-3,-2,-19,-24]\n\n=>\nghci> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]\n[-5,-3,-6,-7,-3,-2,-19,-24]\n\n<!-- 模块 -->\nHaskell 中的模块是含有一组相关的函数，类型和类型类的组合。而 Haskell 进程的本质便是从主模块中引用其它模块并调用其中的函数来运行操作。\n\n加载所有函数\nimport Data.List\n\nnumUniques :: (Eq a) => [a] -> Int\nnumUniques = length . nub\n\n仅加载所需函数\nimport Data.List (nub，sort)\n\n明确不需加载函数\nimport Data.List hiding (nub)\n\n起别名\nimport qualified Data.Map as M\n\n自定义模块\nmodule Geometry\n( sphereVolume\n，sphereArea\n，cubeVolume\n，cubeArea\n，cuboidArea\n，cuboidVolume\n) where\n\nsphereVolume :: Float -> Float\nsphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)\n\nsphereArea :: Float -> Float\nsphereArea radius = 4 * pi * (radius ^ 2)\n\ncubeVolume :: Float -> Float\ncubeVolume side = cuboidVolume side side side\n\ncubeArea :: Float -> Float\ncubeArea side = cuboidArea side side side\n\ncuboidVolume :: Float -> Float -> Float -> Float\ncuboidVolume a b c = rectangleArea a b * c\n\ncuboidArea :: Float -> Float -> Float -> Float\ncuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2\n\nrectangleArea :: Float -> Float -> Float\nrectangleArea a b = a * b\n\n<!-- 定义类型 -->\ndata Shape = Circle Float Float Float | Rectangle Float Float Float Float\n\nghci> :t Circle\nCircle :: Float -> Float -> Float -> Shape\nghci> :t Rectangle\nRectangle :: Float -> Float -> Float -> Float -> Shape\n\nsurface :: Shape -> Float\nsurface (Circle _ _ r) = pi * r ^ 2\nsurface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)\n\n<!-- Record Syntax -->\n 一个数据类型来描述一个人，得包含他的姓、名、年龄、身高、电话号码以及最爱的冰淇淋\n\ndata Person = Person String String Int Float String String deriving (Show)\ndata Person = Person { firstName :: String\n                     , lastName :: String\n                     , age :: Int\n                     , height :: Float\n                     , phoneNumber :: String\n                     , flavor :: String\n                     } deriving (Show)\n\n在 data 声明的后面加上 deriving (Show)，那 Haskell 就会自动将该类型至于 Show 类型类之中。\n\n\n<!-- IO -->\n<- 是用来运算 I/O actions 并将他的结果绑定到名称。\nmain = putStrLn \"hello,world\"\n\nmain = do\n    foo <- putStrLn \"Hello, what's your name?\"\n    name <- getLine\n    putStrLn (\"Hey \" ++ name ++ \", you rock!\")\n\n\n\n```\n\n## 典型例子\n\n函数式编程的一般思路：先取一个初始集合，添加过滤条件，最终取得正确结果。\n\n如何取得三边长度皆为整数且小于等于 10，周长为 24 的直角三角形？\n\n1、列出三边小于等于 10 的三角形\n\n```\nlet triangles = [(a,b,c) | c <- [1..10],b <- [1..10], a<-[1..10] ]\n```\n\n2、加入直角三角形的限制条件，同时满足 b 小于斜边，a 小于 b\n\n```\nghci> let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]\n```\n\n2、加入周长为 24\n\n```\nghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]\n```","preview":"## Haskell 语言总览\n\n命令式编程：a = 5 ; => a = 7;\n\n函数式编程：  \n例子: 阶乘，指从 1 到某个数的乘积。  \n一个串列中数字的和，指把第一个数字和剩余的数字的和相加。\n\n"}
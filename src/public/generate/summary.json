{"fileMap":{"./src/public/generate/index.json":{"siteTitle":"猪年奔跑的前端小伙伴","description":"A site that records our tears, laugh and grow.","copyright":"@猪年奔跑的前端小伙伴","link":"http://github.com","expire":"2019-2020","content":"","preview":""},"./src/public/generate/tech/ecmascript.json":{"title":"ECMAScript 2015-2019 概览","createAt":"2019-05-07T20:55:23.000Z","updateAt":"2019-05-07T20:55:23.000Z","tags":null,"category":null,"author":null,"content":"## ECMAScript 2015\n\n1、添加 Array.prototype.includes 函数\n功能：判断是否包含某个元素。\n\n需要注意的是，includes 函数与 indexOf()函数功能类似，其用法辨析如下：\n\n```js\n// 当元素为NaN时\n  [NaN].includes(NaN) => true\n  [NaN].indexOf(NaN) => -1\n\n// 当元素为 +0 与 -0 时\n  [+0].includes(-0) => true\n  [+0].indexOf(-0) => 0\n```\n\n<!-- more -->\n\n2、添加取幂运算符号 \\*\\*\n示例：\n\n```js\n2 \\*\\* 3 === Math.pow(2,3) => true, 8\n```\n\n## ECMAScript 2016\n\n1、添加 String.padStart 和 String.padEnd\n功能：填充字符串，以达到指定长度。\n\n- 当指定长度小于等于原字符串长度时，返回原字符串\n- 当指定长度大于原字符串长度时，用指定字符串填充，若是未指定字符串，则用空字符填充。\n  示例\n\n```js\n// 前置填充\n\"es8\".padStart(5) => \"  es8\"\n\n\"es8\".padStart(5,\"lian\") => \"lies8\"\n// 后置填充\n\"es8\".padEnd(5) => \"es8  \"\n\n\"es8\".padEnd(5,\"lian\") => \"es8li\"\n```\n\n2、添加 Object.values 和 Object.entries\n功能：返回指定对象的枚举属性值（属性，值）的数组\n示例：\n\n```js\nconst obj = {x:1,y:2}\nObject.values(obj) => [1,2]\n\nObject.entries(obj) => [[x,1],[y,2]]\n```\n\n3、添加 Object.getOwnPropertyDescriptors\n功能：返回指定对象的所有属性描述符\n示例：\n\n```js\nconst obj = {\n  get age(){\n    return 10;\n  }\n}\nObject.getOwnPropertyDescriptors(obj) =>\n{age:{configurable:true,enumerable:true,get:function age(){},set:undefined}}\n```\n\n4、增强字符串模版\n示例：\n\n```js\nconst version = 8;\nfunction helper(strs,...keys){\n  const addit = keys[0]===8? \"better\":\"good\";\n  return `${strs[0]} ${keys[0]} ${strs[1]} ${addit}`\n}\n\nhelper `ES ${version} is` => ES8 is better\n```","preview":"## ECMAScript 2015\n\n1、添加 Array.prototype.includes 函数\n功能：判断是否包含某个元素。\n\n需要注意的是，includes 函数与 indexOf()函数功能类似，其用法辨析如下：\n\n```js\n// 当元素为NaN时\n  [NaN].includes(NaN) => true\n  [NaN].indexOf(NaN) => -1\n\n// 当元素为 +0 与 -0 时\n  [+0].includes(-0) => true\n  [+0].indexOf(-0) => 0\n```\n\n"},"./src/public/generate/tech/haskellOverview.json":{"title":"Haskell 语言总览","createAt":"2019-05-07T21:08:00.000Z","updateAt":"2019-05-07T21:08:00.000Z","tags":null,"category":null,"author":null,"content":"## Haskell 语言总览\n\n命令式编程：a = 5 ; => a = 7;\n\n函数式编程：  \n例子: 阶乘，指从 1 到某个数的乘积。  \n一个串列中数字的和，指把第一个数字和剩余的数字的和相加。\n\n<!-- more -->\n\n## 语法\n\n```hs\n<!-- 运算 -->\n2 + 5\n49 * 100\n1892-1472\n5/2\n\n<!-- 优先级 -->\n(50-100)*50\n\n<!-- 布尔 -->\nTrue\nFalse\n&&\n||\nnot\n\n<!-- 相等性 -->\n5 == 5\n'hello' /= 'hi'\n\n<!-- 中缀函数 -->\n1 + 2\n\n<!-- 前缀函数 -->\nsucc 8\nmax 100 101\n\n<!-- 函数调用拥有最高优先级 -->\nsucc 9 + max 5 4 + 1\n\n<!-- 等效于 -->\n(succ 9) + (max 5 4) + 1\n\n<!-- 自定义函数 -->\n1、新建文件，取名为baby.ts，填写代码：\ndoubleMe x = x + x\n\n2、打开ghci，运行 :l baby.hs\n输入 doubleMe 9\n\n<!-- 组合 -->\ndoubleMe x = x + x\ndoubleUs x y = doubleMe x + doubleMe y\n注意，doubleUs 和 doubleMe 不分顺序\n\n<!-- 基本类型 list -->\nlet numbers = [4,8,15]\n合并\n[1,2] + [3,5] => [1,2,3,5]\n获取元素:!!\n[1,2,3] !! 1 => 2\n嵌套\nlet b = [[1,2],[3,5]]\n比较，从第一个元素开始，以此类推: >\n[3,2,1] > [2,2,1]\n\n获取首元素： head\nhead [1,3,5] => 1\n\n获取除头部之后的部分 : tail\ntail [5,4,3,2,1] => [4,3,2,1]\n\n获取最后一个元素 : last\nlast [1,2,3] => 3\n\n获取除最后一个元素之外的部分 : init\ninit [1,2,3] => [1,2]\n\n返回长度: length\nlength [1,2] => 2\n\n判断是否为空: null\nnull [1] => False\n\n反转: reverse\nreverse [1,2,3] => [3,2,1]\n\n获取前几个元素: take\ntake 2 [1,2,3] => [1,2]\n\n删除前几个元素: drop\ndrop 2 [1,2,3] => [3]\n\n获取最大元素: maximum\nmaximum [1,2,3] => 3\n\n获取最小元素: minimum\nminimum [1,2,3] => 1\n\n获取元素之和: sum\nsum [1,2,3] => 6\n\n获取元素之积: product\nproduct [1,2,3] => 6\n\n判断元素是否存在： elem\n1 `elem` [1,2,3] => True\n\n<!-- range -->\n[1..5] => [1,2,3,4,5]\n[1,3..9] => [1,3,5,7,9]\n\n重复list: cycle\ntake 3 (cycle [1,2]) => [1,2,3]\n\n重复单个元素： repeat\ntake 3 (repeat 5) => [5,5,5]\n\n指定重复次数: replicate\nreplicate 3 10 => [10,10,10]\n\n<!-- comprehension -->\n[ x*2 | x <- [1..3]>] => [2,4,6]\n\n条件\n[ x | x <- [50..100], x `mod` 7 == 3] => [52,59,66,73,80,87,94]\n\n<!-- Tuple -->\n(8,'one')\n\n返回序对的首项： fst\nfst (8,10) => 8\n\n返回序对的尾项： snd\nsnd (8,11) => 11\n\n交叉配对： zip\nzip [1,2] [3,3] => [(1,3),(2,3)]\n\n<!-- 类型推导 -->\n当你写下一个数字，Haskell能自己推断出它的类型\n\n检查类型： :t\n:t 'a' => Char\n\n<!-- 类型声明 -->\n编写函数时，给它一个明确的类型声明是个好习惯\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n\n常见类型\nint 有界整数。对 32 位的机器而言，上限一般是 2147483647，下限是 -2147483648。\n\nInteger,无界整数，效率不如Int高。\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\nFloat 表示单精度的浮点数。\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\nDouble 表示双精度的浮点数。\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n\nBool 表示布尔值，它只有两种值：True 和 False。\n\nChar 表示一个字符。一个字符由单引号括起，一组字符的 List 即为字符串。\n\nTuple 的类型取决于它的长度及其中项的类型。注意，空 Tuple 同样也是个类型，它只有一种值：()。\n\n\n<!-- Typeclasses -->\n描述类型\n\nghci> :t (==)\n(==) :: (Eq a) => a -> a -> Bool\n=> 符号。它左边的部分叫做类型约束。这段类型声明可以这样理解：\"相等函数取两个相同类型的值作为参数并回传一个布尔值，而这两个参数的类型同在 Eq 类之中(即类型约束)\"\n\n常见 Typeclass\n\n判断相等的类型： Eq\n\n比较大小的类型： Ord\n\n可用字符串的类型： show\nshow 3.1 => '3.1'\n\n将字符串转为Read的某成员类型： read\nread \"5\" - 2   => 3\n\n一个表达式后跟:: 的类型注释，以明确其类型\nread \"5\" :: Int  => 5\n\n连续类型： enum\n每个值都有后继子 (successer) 和前置子 (predecesor)，分别可以通过 succ 函数和 pred 函数得到\n[LT .. GT]  => [LT,EQ,GT]\n\n获取边界： maxBound 与 minBound\nminBound :: Int  => -2147483648\nmaxBound :: Char  => '\\1114111'\n\n数字类型： Num\n:t 20  => 20 :: (Num t) => t\n\n表示整数： Intergral\n\n表示浮点类型： Floating\n\n<!-- 模式匹配 -->\n判断一个数字是否是7\nlucky :: (Integral a) => a -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck, pal!\"\n\n实现阶乘\nfactorial :: (Integral a) => a -> a\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\n二位矢量相加\naddVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\n实现  head 函数\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on an empty list, dummy!\"\nhead' (x:_) = x\n\n实现 length 函数\nlength' :: (Num b) => [a] -> b\nlength' [] = 0\nlength' (_:xs) = 1 + length' xs\n\n@模式,在按模式分割时，保留对其整体的引用\ncapital :: String -> String\ncapital \"\" = \"Empty string, whoops!\"\ncapital all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n\ncapital \"Dracula\"  => \"The first letter of Dracula is D\"\n\nguard 跟在函数名及参数、竖线标志之后，通常他们都是靠右一个缩进排成一列。一个 guard 就是一个布尔表达式，如果为真，就使用其对应的函数体。如果为假，就送去见下一个 guard\n检查体重\nbmiTell :: (RealFloat a) => a -> String\nbmiTell bmi\n    | bmi <= 18.5 = \"You're underweight, you emo, you!\"\n    | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise   = \"You're a whale, congratulations!\"\n\n实现 max 函数\nmax' :: (Ord a) => a -> a -> a\nmax' a b\n    | a > b     = a\n    | otherwise = b\n\nwhere 关键字，定义名字\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weight height\n    | weight / height ^ 2 <= 18.5 = \"You're underweight, you emo, you!\"\n    | weight / height ^ 2 <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | weight / height ^ 2 <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise                   = \"You're a whale, congratulations!\"\n\n    =>\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weight height\n    | bmi <= 18.5 = \"You're underweight, you emo, you!\"\n    | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise   = \"You're a whale, congratulations!\"\n    where bmi = weight / height ^ 2\n\n=>\n\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weight height\n    | bmi <= skinny = \"You're underweight, you emo, you!\"\n    | bmi <= normal = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= fat    = \"You're fat! Lose some weight, fatty!\"\n    | otherwise     = \"You're a whale, congratulations!\"\n    where bmi = weight / height ^ 2\n          skinny = 18.5\n          normal = 25.0\n          fat = 30.0\n\nlet 关键字，定义局部名字\n求圆柱体表面积\ncylinder :: (RealFloat a) => a -> a -> a\ncylinder r h =\n    let sideArea = 2 * pi * r * h\n        topArea = pi * r ^2\n    in  sideArea + 2 * topArea\n\ncase，前面提到的匹配模式其实是case的语法糖\n\nhead' :: [a] -> a\nhead' [] = error \"No head for empty lists!\"\nhead' (x:_) = x\n=>\nhead' :: [a] -> a\nhead' xs = case xs of [] -> error \"No head for empty lists!\"\n                      (x:_) -> x\n\n<!-- 递归 -->\n斐波那契数列\n\n实现 取列表的最大元素\nmaximum' :: (Ord a) => [a] -> a\nmaximum' [] = error \"maximum of empty list\"\nmaximum' [x] = x\nmaximum' (x:xs)\n    | x > maxTail = x\n    | otherwise = maxTail\n    where maxTail = maximum' xs\n\n实现反转\nreverse' :: [a] -> [a]\nreverse' [] = []\nreverse' (x:xs) = reverse' xs ++ [x]\n\n实现 zip\nzip' :: [a] -> [b] -> [(a,b)]\nzip' _ [] = []\nzip' [] _ = []\nzip' (x:xs) (y:ys) = (x,y):zip' xs ys\n\n实现 elem\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' a [] = False\nelem' a (x:xs)\n    | a == x    = True\n    | otherwise = a `elem'` xs\n\n快速排序\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let smallerSorted = quicksort [a | a <- xs, a <= x]\n      biggerSorted = quicksort [a | a <- xs, a > x]\n  in smallerSorted ++ [x] ++ biggerSorted\n\n<!-- 高端函数 -->\n本质上，Haskell所有函数只有一个参数\nghci> max 4 5\n5\nghci> (max 4) 5\n5\n\n实现 zipWith。 它取一个函数和两个 List 做参数，并把两个 List 交到一起(使相应的元素去调用该函数)。\n\nzipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith' _ [] _ = []\nzipWith' _ _ [] = []\nzipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys\n\nzipWith' max [6,3,2,1] [7,3,1,5]  => [7,3,2,5]\n\n实现 flip，取一个函数作参数并回传一个相似的函数，其中它们的参数颠倒了。\nflip' :: (a -> b -> c) -> b -> a -> c\nflip' f y x = f x y\n\nghci> flip' zip [1,2,3,4,5] \"hello\"\n[('h',1),('e',2),('l',3),('l',4),('o',5)]\n\n实现 map，取一个函数和 List 做参数，遍历该 List 的每个元素来调用该函数产生一个新的 List。\n\nmap :: (a -> b) -> [a] -> [b]\nmap _ [] = []\nmap f (x:xs) = f x : map f xs\n\n实现filter，取一个限制条件和一个 List，回传该 List 中所有符合该条件的元素\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter _ [] = []\nfilter p (x:xs)\n    | p x       = x : filter p xs\n    | otherwise = filter p xs\n\n<!-- lambda -->\n匿名函数， \\ (因为它看起来像是希腊字母的 lambda)，后面是用空格分隔的参数，-> 后面就是函数体。\n\n实现 flip\nflip' :: (a -> b -> c) -> b -> a -> c\nflip' f = \\x y -> f y x\n\n<!-- fold -->\n实现 sum\nsum' :: (Num a) => [a] -> a\nsum' xs = foldl (\\acc x -> acc + x) 0 xs\n\n=>\n\nsum' :: (Num a) => [a] -> a\nsum' = foldl (+) 0\n\n常用库函数\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' y ys = foldl (\\acc x -> if x == y then True else acc) False ys\n\nmap' :: (a -> b) -> [a] -> [b]\nmap' f xs = foldr (\\x acc -> f x : acc) [] xs\n\nmaximum' :: (Ord a) => [a] -> a\nmaximum' = foldr1 (\\x acc -> if x > acc then x else acc)\n\nreverse' :: [a] -> [a]\nreverse' = foldl (\\acc x -> x : acc) []\n\nproduct' :: (Num a) => [a] -> a\nproduct' = foldr1 (*)\n\nfilter' :: (a -> Bool) -> [a] -> [a]\nfilter' p = foldr (\\x acc -> if p x then x : acc else acc) []\n\nhead' :: [a] -> a\nhead' = foldr1 (\\x _ -> x)\n\nlast' :: [a] -> a\nlast' = foldl1 (\\_ x -> x)\n\n<!-- $ 函数 -->\n函数调用符，优先级最低\n\nsum (map sqrt [1..130])。由于低优先级的 $，我们可以将其改为 sum $ map sqrt [1..130]，可以省敲不少键！\n\n<!-- 函数组合 -->\n将多个函数组合，即 . 函数\n定义：\n(.) :: (b -> c) -> (a -> b) -> a -> c\nf . g = \\x -> f (g x)\n\n示例\nghci> map (\\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]\n[-5,-3,-6,-7,-3,-2,-19,-24]\n\n=>\nghci> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]\n[-5,-3,-6,-7,-3,-2,-19,-24]\n\n<!-- 模块 -->\nHaskell 中的模块是含有一组相关的函数，类型和类型类的组合。而 Haskell 进程的本质便是从主模块中引用其它模块并调用其中的函数来运行操作。\n\n加载所有函数\nimport Data.List\n\nnumUniques :: (Eq a) => [a] -> Int\nnumUniques = length . nub\n\n仅加载所需函数\nimport Data.List (nub，sort)\n\n明确不需加载函数\nimport Data.List hiding (nub)\n\n起别名\nimport qualified Data.Map as M\n\n自定义模块\nmodule Geometry\n( sphereVolume\n，sphereArea\n，cubeVolume\n，cubeArea\n，cuboidArea\n，cuboidVolume\n) where\n\nsphereVolume :: Float -> Float\nsphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)\n\nsphereArea :: Float -> Float\nsphereArea radius = 4 * pi * (radius ^ 2)\n\ncubeVolume :: Float -> Float\ncubeVolume side = cuboidVolume side side side\n\ncubeArea :: Float -> Float\ncubeArea side = cuboidArea side side side\n\ncuboidVolume :: Float -> Float -> Float -> Float\ncuboidVolume a b c = rectangleArea a b * c\n\ncuboidArea :: Float -> Float -> Float -> Float\ncuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2\n\nrectangleArea :: Float -> Float -> Float\nrectangleArea a b = a * b\n\n<!-- 定义类型 -->\ndata Shape = Circle Float Float Float | Rectangle Float Float Float Float\n\nghci> :t Circle\nCircle :: Float -> Float -> Float -> Shape\nghci> :t Rectangle\nRectangle :: Float -> Float -> Float -> Float -> Shape\n\nsurface :: Shape -> Float\nsurface (Circle _ _ r) = pi * r ^ 2\nsurface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)\n\n<!-- Record Syntax -->\n 一个数据类型来描述一个人，得包含他的姓、名、年龄、身高、电话号码以及最爱的冰淇淋\n\ndata Person = Person String String Int Float String String deriving (Show)\ndata Person = Person { firstName :: String\n                     , lastName :: String\n                     , age :: Int\n                     , height :: Float\n                     , phoneNumber :: String\n                     , flavor :: String\n                     } deriving (Show)\n\n在 data 声明的后面加上 deriving (Show)，那 Haskell 就会自动将该类型至于 Show 类型类之中。\n\n\n<!-- IO -->\n<- 是用来运算 I/O actions 并将他的结果绑定到名称。\nmain = putStrLn \"hello,world\"\n\nmain = do\n    foo <- putStrLn \"Hello, what's your name?\"\n    name <- getLine\n    putStrLn (\"Hey \" ++ name ++ \", you rock!\")\n\n\n\n```\n\n## 典型例子\n\n函数式编程的一般思路：先取一个初始集合，添加过滤条件，最终取得正确结果。\n\n如何取得三边长度皆为整数且小于等于 10，周长为 24 的直角三角形？\n\n1、列出三边小于等于 10 的三角形\n\n```\nlet triangles = [(a,b,c) | c <- [1..10],b <- [1..10], a<-[1..10] ]\n```\n\n2、加入直角三角形的限制条件，同时满足 b 小于斜边，a 小于 b\n\n```\nghci> let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]\n```\n\n2、加入周长为 24\n\n```\nghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]\n```","preview":"## Haskell 语言总览\n\n命令式编程：a = 5 ; => a = 7;\n\n函数式编程：  \n例子: 阶乘，指从 1 到某个数的乘积。  \n一个串列中数字的和，指把第一个数字和剩余的数字的和相加。\n\n"},"./src/public/generate/tech/macTool.json":{"title":"Mac 小工具","createAt":"2019-05-07T20:59:58.000Z","updateAt":"2019-05-07T20:59:58.000Z","tags":null,"category":null,"author":null,"content":"## 简介\n\n> 论语有云：工欲善其事，必先利其器。\n\n我有一台 Mac 电脑，平日编程、写作、整理材料均在其上完成。时间久了，自然积累了一些提高效率与体验的工具。现特地整理记录如下，以供参考。\n\n## 小工具\n\n1、Bandwidth+\n\n> 简介\n\n监控电脑上传与下载速度\n\n> 效果\n\n![效果](public/images/bandwidth.png)\n\n<!-- more -->\n\n> 链接\n\nhttps://itunes.apple.com/us/app/bandwidth/id490461369?mt=12\n\n(待续)","preview":"## 简介\n\n> 论语有云：工欲善其事，必先利其器。\n\n我有一台 Mac 电脑，平日编程、写作、整理材料均在其上完成。时间久了，自然积累了一些提高效率与体验的工具。现特地整理记录如下，以供参考。\n\n## 小工具\n\n1、Bandwidth+\n\n> 简介\n\n监控电脑上传与下载速度\n\n> 效果\n\n![效果](public/images/bandwidth.png)\n\n"},"./src/public/generate/tech/markdownService.json":{"title":"Markdown 服务器层设计","createAt":"2019-05-07T20:52:05.000Z","updateAt":"2019-05-07T20:52:05.000Z","tags":null,"category":null,"author":null,"content":"## 简介\n\n何为网站？前端获取数据，加以恰当样式，呈现于用户，如此构成网站之雏形。\n\n然而前端渲染层获取数据，不宜直接取之于数据源。  \n数据源数据多且杂，宜增加一服务层，接管数据之增删改查，对外提供抽象一致接口。\n\n<!-- more -->\n\n## 相关接口\n\n服务层提供接口，分类归总如下\n\n## 首页\n\n1、网站基本信息\n\n```\n函数：siteBaseInfo\n入参：none\n出参：title,description,copyright\n(网站标题，副标题，版权拥有者)\n```\n\n2、文章列表\n\n```\n函数：homePostList\n入参：pageSize,pageNo(每页数量，当前页码)\n出参：total,pageSize,pageNo,postList{postId,title,tags,createAt,preview}\n(总数,文章列表{文章 ID，标题，标签，创建时间，预览内容})\n```\n\n3、搜索文章\n\n```\n函数：searchPostList\n入参：keyword\n出参：total,pageSize,pageNo,postList{postId,title,tags,createAt,preview,search}\n```\n\n## 文章页\n\n1、文章详情\n\n```\n函数：postDetail\n入参：postId\n出参：postId,title,tags,createAt,updateAt,preview,content\n(文章 ID，标题，标签，创建时间，修改时间，预览内容，完整内容)\n```\n\n## 归档页\n\n1、归档文章列表\n\n```\n函数：archivePostList\n入参：pageSize,pageNo,type=[year,month]\n出参：total,pageSize,pageNo,postList:[year]{postId,title,tags,createAt,preview}\n(总数，年份{创建时间，标题})\n```\n\n## 分类页| 标签页\n\n1、分类列表\n\n```\n函数：tagList\n入参：type=[tag,category]\n出参：total,type,postList{title,count}\n(总数，分类列表{题目，数量})\n```\n\n2、分类详情\n\n```\n函数：tagPostList\n入参：pageSize,pageNo,type=[tag,category],name\n出参：total,type,pageSize,pageNo,postList{postId,title,tags,createAt,preview}\n```\n\n## 关于页\n\nTodo...\n\n## 招聘页\n\nTodo...","preview":"## 简介\n\n何为网站？前端获取数据，加以恰当样式，呈现于用户，如此构成网站之雏形。\n\n然而前端渲染层获取数据，不宜直接取之于数据源。  \n数据源数据多且杂，宜增加一服务层，接管数据之增删改查，对外提供抽象一致接口。\n\n"},"./src/public/generate/tech/webpack.json":{"title":"构建利器 Webpack","createAt":"2019-05-07T21:13:48.000Z","updateAt":"2019-05-07T21:13:48.000Z","tags":null,"category":null,"author":null,"content":"## 简介\n\nwebpack 是一个 JavaScript 程序的静态模块打包器。\n\n其工作原理是：webpack 以递归方式构建一个关系依赖图，囊括 JavaScript 程序需要的各个模块，然后将这些模块打包成一个或多个依赖包(bundle)。\n\n<!-- more -->\n\n## 配置矩阵\n\nwebpack 配置的组成矩阵：入口 entry，输出 output，加载器 loader，插件 plugin。\n\n## 入口\n\n用法:\n\n```js\n// 简写语法\nentry: string | string[]\n// 对象语法\nentry: {\n  [entryChunkName: string]: string | string[]\n}\n```\n\n## 输出\n\n用法：\n\n```js\n// 简写语法\noutput: {\n  filename:  string,\n  path: string,\n  publicPath: string\n}\n\n// 示例\n{\n  entry: {\n    app: './src/app.js',\n    search: './src/search.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: __dirname + '/dist'\n  }\n}\n\n// 写入到硬盘：./dist/app.js, ./dist/search.js\n```\n\n## 模式(补充)\n\n配置模式 mode，告知 webpack 使用相应模式的内置优化。\n\n```js\n// 用法\n{\n  mode: \"development\" | \"production\";\n}\n\n// 示例\nmodule.exports = {\n  mode: \"development\"\n};\n// development 等效于\nmodule.exports = {\n  plugins: [\n    new webpack.NamedModulesPlugin(),\n    new webpack.DefinePlugin({\n      \"process.env.NODE_ENV\": JSON.stringify(\"development\")\n    })\n  ]\n};\nmodule.exports = {\n  mode: \"production\"\n};\n// production 等效于\nmodule.exports = {\n  plugins: [\n    new UglifyJsPlugin(/* ... */),\n    new webpack.DefinePlugin({\n      \"process.env.NODE_ENV\": JSON.stringify(\"production\")\n    }),\n    new webpack.optimize.ModuleConcatenationPlugin(),\n    new webpack.NoEmitOnErrorsPlugin()\n  ]\n};\n```\n\n## 加载器\n\n加载器，允许你在加载文件时对文件进行预处理。\n整体配置如下：\n1、安装依赖包，如 ts-loader\n\n```bash\nnpm install --save-dev ts-loader\n```\n\n2、在配置文件 webpack.config.js 上，添加内容\n\n```js\n{\n  module: {\n    rules: [{ test: /\\.ts$/, use: \"ts-loader\" }];\n  }\n}\n```\n\n## 插件\n\n插件是 webpack 的核心功能。其本质是一个 JavaScript 对象，内置一个 apply 方法，通过此方法可访问 webpack 的 compiler 对象。\n\n示例：\n\n```js\nconst pluginName = \"ConsoleLogOnBuildWebpackPlugin\";\n\nclass ConsoleLogOnBuildWebpackPlugin {\n  apply(compiler) {\n    compiler.hooks.run.tap(pluginName, compilation => {\n      console.log(\"webpack 构建过程开始！\");\n    });\n  }\n}\n```\n\n整体配置如下：\n1、安装依赖包\n\n```bash\nnpm install --save-dev html-webpack-plugin\n```\n\n2、在配置文件 babel.config.js 上，添加内容\n\n```js\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nconst config = {\n  plugins: [new HtmlWebpackPlugin({ template: \"./src/index.html\" })]\n};\n\nmodule.exports = config;\n```\n\n## web 服务器\n\nwebpack 提供一个简单的 web 服务器 webpack-dev-server，让我们在开发时启动 web 服务。\n\n整体配置如下：\n\n1、安装依赖包\n\n```bash\nnpm i --save-dev webpack-dev-server webpack-merge\n```\n\n2、在配置文件 package.json 上，添加内容\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"webpack-dev-server --open --config webpack.config.js\"\n  }\n}\n```\n\n3、在配置文件 webpack.config.js 上，添加内容\n\n```js\n{\n  // 使用 source map\n  devtool:'inline-source-map',\n  // 服务器参数\n  devServer:{\n    contentBase:\"./dist\"\n  }\n}\n```\n\n## 实践\n\n1、安装依赖包\n\n```bash\nnpm install --save-dev webpack webpack-cli webpack-merge\n```\n\n2、配置启动命令\n在配置文件 package.json 上，添加内容\n\n```js\n{\n  \"scripts\":{\n    \"start\":\"webpack --config webpack.config.js\"\n  }\n}\n```\n\n3、添加解析规则\n在配置文件 webpack.config.js 上，添加内容\n\n```js\n{\n  \"resolve\": {\n    extensions:['.js','.ts','.tsx'],\n    alias:{\n      \"@\": path.resolve(__dirname, 'src/'),\n      utils: path.resolve(__dirname,'src/utils/')\n    }\n  }\n}\n```\n\n## 常用加载器(附录)\n\n1、加载 css\n\n```js\n// 安装依赖包\nnpm install --save-dev style-loader css-loader\n\n// 在配置文件 webpack.config.js 上，添加内容\n{\n  test:/\\.css$/,\n  use:[\n    'style-loader',\n    'css-loader'\n  ]\n}\n```\n\n2、加载 less\n\n```js\n// 安装依赖包\nnpm install --save-dev less-loader less\n\n// 在配置文件 webpack.config.js 上，添加内容\n{\n  test:/\\.less$/,\n  use: [\n    {\n      loader: \"style-loader\"\n    },\n    {\n      loader: \"css-loader\"\n    },\n    {\n      loader: \"less-loader\"\n    }\n  ]\n}\n```\n\n3、加载图片\n\n```js\n// 安装依赖包\nnpm install --save-dev file-loader\n\n// 在配置文件 webpack.config.js 上，添加内容\n{\n  test: /\\.(png|svg|jpg|gif)$/,\n  use:'file-loader'\n}\n\n```\n\n4、加载 ts\n\n```js\n// 安装依赖包\nnpm install --save-dev ts-loader\n\n// 在配置文件 webpack.config.js 上，添加内容\n{\n  test: /\\.tsx?$/,\n  use:'ts-loader'\n}\n```\n\n5、加载 ts\n\n```js\n// 安装依赖包\nnpm install --save-dev awesome-typescript-loader\n\n\n// 在配置文件 webpack.config.js 上，添加内容\n{\n  test: /\\.tsx?$/,\n  use:'awesome-typescript-loader'\n},\n{\n  enforce:\"pre\",\n  test:/\\.js$/,\n  loader:\"source-map-loader\"\n}\n```\n\n6、加载 json\n\n```js\n// 安装依赖包\nnpm install --save-dev json-loader\n\n\n// 在配置文件 webpack.config.js 上，添加内容\n{\n  test: /\\.json$/,\n  use:'json-loader'\n}\n```\n\n7、加载 html\n\n```js\n// 安装依赖包\nnpm install --save-dev html-loader\n\n// 在配置文件 webpack.config.js 上，添加内容\n\n{\n  test: /\\.html$/,\n  use: [\n    {\n      loader: \"html-loader\",\n      options: {\n        minimize: true\n      }\n    }\n  ]\n}\n```\n\n## 常见插件(附录)\n\n1、html-webpack-plugin\n\n```js\n// 安装依赖包\nnpm install --save-dev html-webpack-plugin\n\n// 在配置文件 webpack.config.js 上，添加内容\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nconst config = {\n  plugins:[\n    new HtmlWebpackPlugin({\n      filename: \"index.html\",\n      template: \"./src/index.html\",\n      inject: true\n      })\n  ]\n}\n```\n\n2、clean-webpack-plugin\n\n```js\n// 安装依赖包\nnpm install --save-dev clean-webpack-plugin\n\n// 在配置文件 webpack.config.js 上，添加内容\nconst CleanWebpackPlugin = require('clean-webpack-plugin');\n\nconst config = {\n  plugins:[\n    new CleanWebpackPlugin(['dist'])\n  ]\n}\n\n```\n\n3、uglifyjs-webpack-plugin\n\n```js\n// 安装依赖包\nnpm install --save-dev uglifyjs-webpack-plugin\n\n// 在配置文件 webpack.config.js 上，添加内容\nconst UglifyJSPlugin = require(\"uglifyjs-webpack-plugin\");\n\nconst config = {\n  plugins:[\n        new UglifyJSPlugin({\n      uglifyOptions: {\n        compress: {\n          drop_console: true\n        }\n      },\n      sourceMap: true\n    }),\n  ]\n}\n```\n\n4、copy-webpack-plugin\n\n```js\n// 安装依赖包\nnpm install --save-dev copy-webpack-plugin\n\n// 在配置文件 webpack.config.js 上，添加内容\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\n\nconst config = {\n    plugins: [\n    new CopyWebpackPlugin([{ from: \"src/images\", to: \"images\" }])\n  ]\n}\n```\n\n5、webpack-bundle-analyzer\n\n```js\n// 安装依赖包\nnpm install --save-dev webpack-bundle-analyzer\n\n// 在配置文件 webpack.config.js 上，添加内容\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\n\nconst config = {\n    plugins: [\n    new BundleAnalyzerPlugin()\n  ]\n}\n```\n\n(完)","preview":"## 简介\n\nwebpack 是一个 JavaScript 程序的静态模块打包器。\n\n其工作原理是：webpack 以递归方式构建一个关系依赖图，囊括 JavaScript 程序需要的各个模块，然后将这些模块打包成一个或多个依赖包(bundle)。\n\n"}}}